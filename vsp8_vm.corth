/*
The compiler commands are (), int, #, [], and for. # tells the compiler to declare
a macro for compile time use only. () indicates a macro call. int tells
the compiler to declare a variable for compile time use only. for describes a variable
manipulation and incrementation scheme. Understand that this is not actually going to
create a for loop in the resulting program. Rather, it creates a loop with
variables that can be used to write code based on those variables.
All variables declared inside a macro are specific there, same with for loops.
All variables declared outside anything are global. for can also be used as an if
statement with flag. Lables work the same way as variables in terms of global vs
non-global. Note that only vsb code written directly or in a macro call from direct code
will be compiled.

The commands that actually produce vsb code are if, else, adr, :, =, goto, and out.
adr or out statement required inside an if statement. Optional assignment with adr.
Out takes zero to two parameters, adr can take between zero and two; first is
the value to assign it to and the second is the mask for assignment (1 = assign,
0 = protect). : is placed after a lable to use with goto. A space can be put after
the label and before the colon, then either global or local is stated. Default is global.

Spaces after each command or none, then parenthesis. Semicolons only inside for loops. Commas
for multiple arguments. Tab deliniation for loops, not brackets. Note that parenthesis
are optional but may be needed to ensure the correct grouping. Spacing can be arbitrary,
just ensure that tab deliniation lines up. Square brackets need to be used if combining a
compiler variable with a label. If a compiler variable is used elsewhere, just treat it
like a normal number. Order of operations is strictly left to right unless there are
parenthesis.

In a way, for is a special kind of macro. It defines manipulation of variables and allows
looping until something occurs. When it loops, it prints the body of the for loop to the
compiled vsp file. Note that this compiles to vsp assembly, requiring a bit extra processing
to compile to vsp upload code (maybe just combine the two processes into one though). Note
that, since for loops are a type of macro, they can have local labels declared within them.

Don't need goto's for pre-compiled code because these kinds of things should be incorporated
into the vsp code itself using vsp if-else, goto, etc.

Compiling Process:
- Scan for global variables and malloc() them to integers.
- Scan for macros and repeat until no macros are left (except for "for" loops).
Malloc() and free() specific varaibles for those macros.
- Scan again and, if reach a for loop, interpret each statement and
buffer them. Then, repeat the contents of the for loop as if it was a macro,
using the malloc/free rules from before and incrementing or manipulating
variables as specified until reach point where condition is false, then
move on. If condition is false to begin with, then don't print contents at all.
*The other action that occurs simutaneously is replacing variables
with their actual values. Ex: (1<<(x+2)) becomes (1<<(4+2)) if x happens to
be 4 at that time.
- Scan again and actually evaluate the expressions. (1<<(4+2)) becomes 0040.
Note that everthing is written in hex as an int, and everything is stored that way.
So, even though (1<<31)/(1<<30) should equal 2, it will actually result in overflows
and be weird. Note that the leading zeros can be eliminated if you want.
- Scan again and simply translate the labels, gotos, if-else statements, adr(), and
out() statements into vsb assembly. Lables simply add a no-op and then store the
location in an array. If variables are in brackets appended to the label, their value
is printed, ommitting preceding zeros & keeping brackets. A special tag is added for local
tags, and this tag is added to gotos for it too. Gotos add a no-op that goes to the label
spot. If there are brackets, the value is inserted, ommitting preceding zeros and keeping brakcets.
if and else result in either a jmpr or jmpi depending on the contents of the if(), then an even
address for the else statement from that and an odd address for the contents of the
if statement from that. adr() and out() just result in a couple adr1/adr0 and out1/out0
lines to set the address/output to that with a mask. If the value written is ffff or
0000 then only one line of vsb assembly is needed. An adr() statement can be followed by an =
and then a number. If the number is zero, buf0 is written. If the value is non-zero, buf1
is written.
*/

/*lsb is bit zero; msb is bit 7*/
int (x, y, z)
start:
for (x = 0; x < 8; x = x+1)
	if (adr(0000+x))
		adr() = 0
	else
		adr() = 1
		goto path
path:
adr(c000) = 0
for (x = 0; x < 8; x++)
	path[x]:
	adr(0000+x)
	goto pathjump
pathjump:
if (adr())
	goto put[1]
else
	goto put[0]
for (y = 0; y < 2; y = y+1)
	put[y]:
	adr(8000)
	for (x = 8, z = 0; z < 8; z = z+1, x = x<<1)
		develop(x, y, z)
path[8]:
for (x = 0; x < 8; x++)
	if (adr(x, 7))
		out(ffff, 1<<x)
	else
		out(0000, 1<<x)
for (x = 0; x < 8; x = x+1)
	if (adr(0000+x))
		out(ffff, 1<<(x+8))
	else
		out(0000, 1<<(x+8))
goto start

#develop(x, y, z)
	int (f)
	if (adr(4000, 4000))
		if (adr(0000, 4000))
			adr(ffff, x*y)
	else
		adr() = 1
		adr(0000, 4000) = y
		for (f = 0; (!(z == 7))&&(!f); f = 1)
			adr(4000+(x*y)+z, 7800+x*y)) = 0
		goto path[x+1]
